// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target x86_64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name Moya
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Alamofire
import Foundation
@_exported import Moya
import Swift
import UIKit.UIImage
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol AccessTokenAuthorizable {
  var authorizationType: AuthorizationType? { get }
}
public enum AuthorizationType {
  case basic
  case bearer
  case custom(String)
  public var value: String {
    get
  }
}
extension AuthorizationType : Equatable {
  public static func == (lhs: AuthorizationType, rhs: AuthorizationType) -> Bool
}
public struct AccessTokenPlugin : PluginType {
  public typealias TokenClosure = (TargetType) -> String
  public let tokenClosure: TokenClosure
  public init(tokenClosure: @escaping TokenClosure)
  public func prepare(_ request: URLRequest, target: TargetType) -> URLRequest
}
public protocol Cancellable {
  var isCancelled: Bool { get }
  func cancel()
}
final public class CredentialsPlugin : PluginType {
  public typealias CredentialClosure = (TargetType) -> URLCredential?
  public init(credentialsClosure: @escaping CredentialClosure)
  final public func willSend(_ request: RequestType, target: TargetType)
  @objc deinit
}
public enum EndpointSampleResponse {
  case networkResponse(Int, Data)
  case response(HTTPURLResponse, Data)
  case networkError(NSError)
}
open class Endpoint {
  public typealias SampleResponseClosure = () -> EndpointSampleResponse
  final public let url: String
  final public let sampleResponseClosure: SampleResponseClosure
  final public let method: Moya.Method
  final public let task: Task
  final public let httpHeaderFields: [String : String]?
  public init(url: String, sampleResponseClosure: @escaping SampleResponseClosure, method: Moya.Method, task: Task, httpHeaderFields: [String : String]?)
  open func adding(newHTTPHeaderFields: [String : String]) -> Endpoint
  open func replacing(task: Task) -> Endpoint
  @objc deinit
}
extension Endpoint {
  public func urlRequest() throws -> URLRequest
}
extension Endpoint : Equatable, Hashable {
  public func hash(into hasher: inout Hasher)
  public static func == (lhs: Endpoint, rhs: Endpoint) -> Bool
  open var hashValue: Swift.Int {
    get
  }
}
public typealias ImageType = UIImage
public typealias Image = ImageType
public typealias Session = Alamofire.Session
public typealias Method = Alamofire.HTTPMethod
public typealias ParameterEncoding = Alamofire.ParameterEncoding
public typealias JSONEncoding = Alamofire.JSONEncoding
public typealias URLEncoding = Alamofire.URLEncoding
public typealias RequestMultipartFormData = Alamofire.MultipartFormData
public typealias DownloadDestination = Alamofire.DownloadRequest.Destination
extension Request : RequestType {
  public var sessionHeaders: [String : String] {
    get
  }
}
public typealias RequestInterceptor = Alamofire.RequestInterceptor
@_hasMissingDesignatedInitializers final public class CancellableToken : Cancellable, CustomDebugStringConvertible {
  final public var isCancelled: Swift.Bool {
    get
  }
  final public func cancel()
  public init(action: @escaping () -> Void)
  final public var debugDescription: String {
    get
  }
  @objc deinit
}
public enum MoyaError : Swift.Error {
  case imageMapping(Response)
  case jsonMapping(Response)
  case stringMapping(Response)
  case objectMapping(Swift.Error, Response)
  case encodableMapping(Swift.Error)
  case statusCode(Response)
  case underlying(Swift.Error, Response?)
  case requestMapping(String)
  case parameterEncoding(Swift.Error)
}
extension MoyaError {
  public var response: Moya.Response? {
    get
  }
}
extension MoyaError : LocalizedError {
  public var errorDescription: String? {
    get
  }
}
extension MoyaError : CustomNSError {
  public var errorUserInfo: [String : Any] {
    get
  }
}
public typealias Completion = (_ result: Result<Moya.Response, MoyaError>) -> Void
public typealias ProgressBlock = (_ progress: ProgressResponse) -> Void
public struct ProgressResponse {
  public let response: Response?
  public let progressObject: Progress?
  public init(progress: Progress? = nil, response: Response? = nil)
  public var progress: Double {
    get
  }
  public var completed: Bool {
    get
  }
}
public protocol MoyaProviderType : AnyObject {
  associatedtype Target : Moya.TargetType
  func request(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> Cancellable
}
open class MoyaProvider<Target> : MoyaProviderType where Target : Moya.TargetType {
  public typealias EndpointClosure = (Target) -> Endpoint
  public typealias RequestResultClosure = (Result<URLRequest, MoyaError>) -> Void
  public typealias RequestClosure = (Endpoint, @escaping RequestResultClosure) -> Void
  public typealias StubClosure = (Target) -> Moya.StubBehavior
  final public let endpointClosure: EndpointClosure
  final public let requestClosure: RequestClosure
  final public let stubClosure: StubClosure
  final public let session: Session
  final public let plugins: [PluginType]
  final public let trackInflights: Bool
  open var inflightRequests: [Endpoint : [Moya.Completion]] {
    get
  }
  public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping, requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping, stubClosure: @escaping StubClosure = MoyaProvider.neverStub, callbackQueue: DispatchQueue? = nil, session: Session = MoyaProvider<Target>.defaultAlamofireSession(), plugins: [PluginType] = [], trackInflights: Bool = false)
  open func endpoint(_ token: Target) -> Endpoint
  @discardableResult
  open func request(_ target: Target, callbackQueue: DispatchQueue? = .none, progress: ProgressBlock? = .none, completion: @escaping Completion) -> Cancellable
  @discardableResult
  open func stubRequest(_ target: Target, request: URLRequest, callbackQueue: DispatchQueue?, completion: @escaping Moya.Completion, endpoint: Endpoint, stubBehavior: Moya.StubBehavior) -> CancellableToken
  @objc deinit
}
public enum StubBehavior {
  case never
  case immediate
  case delayed(seconds: TimeInterval)
}
extension MoyaProvider {
  final public class func neverStub(_: Target) -> Moya.StubBehavior
  final public class func immediatelyStub(_: Target) -> Moya.StubBehavior
  final public class func delayedStub(_ seconds: TimeInterval) -> (Target) -> Moya.StubBehavior
}
public func convertResponseToResult(_ response: HTTPURLResponse?, request: URLRequest?, data: Data?, error: Swift.Error?) -> Result<Moya.Response, MoyaError>
extension MoyaProvider {
  final public class func defaultEndpointMapping(for target: Target) -> Endpoint
  final public class func defaultRequestMapping(for endpoint: Endpoint, closure: RequestResultClosure)
  final public class func defaultAlamofireSession() -> Session
}
extension Method {
  public var supportsMultipart: Bool {
    get
  }
}
extension MoyaProvider {
  public func requestNormal(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -> Cancellable
  public func cancelCompletion(_ completion: Moya.Completion, target: Target)
  final public func createStubFunction(_ token: CancellableToken, forTarget target: Target, withCompletion completion: @escaping Moya.Completion, endpoint: Endpoint, plugins: [PluginType], request: URLRequest) -> (() -> Void)
  final public func notifyPluginsOfImpendingStub(for request: URLRequest, target: Target) -> URLRequest
}
public struct MultipartFormData : Hashable {
  public enum FormDataProvider : Hashable {
    case data(Foundation.Data)
    case file(URL)
    case stream(InputStream, UInt64)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Moya.MultipartFormData.FormDataProvider, b: Moya.MultipartFormData.FormDataProvider) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(provider: FormDataProvider, name: String, fileName: String? = nil, mimeType: String? = nil)
  public let provider: FormDataProvider
  public let name: String
  public let fileName: String?
  public let mimeType: String?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Moya.MultipartFormData, b: Moya.MultipartFormData) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum MultiTarget : TargetType {
  case target(TargetType)
  public init(_ target: TargetType)
  public var path: String {
    get
  }
  public var baseURL: URL {
    get
  }
  public var method: Moya.Method {
    get
  }
  public var sampleData: Data {
    get
  }
  public var task: Task {
    get
  }
  public var validationType: ValidationType {
    get
  }
  public var headers: [String : String]? {
    get
  }
  public var target: TargetType {
    get
  }
}
extension MultiTarget : AccessTokenAuthorizable {
  public var authorizationType: AuthorizationType? {
    get
  }
}
public enum NetworkActivityChangeType {
  case began, ended
  public static func == (a: Moya.NetworkActivityChangeType, b: Moya.NetworkActivityChangeType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class NetworkActivityPlugin : PluginType {
  public typealias NetworkActivityClosure = (_ change: NetworkActivityChangeType, _ target: TargetType) -> Void
  public init(networkActivityClosure: @escaping NetworkActivityClosure)
  final public func willSend(_ request: RequestType, target: TargetType)
  final public func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)
  @objc deinit
}
final public class NetworkLoggerPlugin {
  final public var configuration: Configuration
  public init(configuration: Configuration = Configuration())
  @objc deinit
}
extension NetworkLoggerPlugin : PluginType {
  final public func willSend(_ request: RequestType, target: TargetType)
  final public func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)
}
extension NetworkLoggerPlugin {
  public struct Configuration {
    public typealias OutputType = (_ target: TargetType, _ items: [String]) -> Void
    public var formatter: Formatter
    public var output: OutputType
    public var logOptions: LogOptions
    public init(formatter: Formatter = Formatter(), output: @escaping OutputType = defaultOutput, logOptions: LogOptions = .default)
    public static func defaultOutput(target: TargetType, items: [String])
  }
}
extension NetworkLoggerPlugin.Configuration {
  public struct LogOptions : OptionSet {
    public let rawValue: Int
    public init(rawValue: Int)
    public static let requestMethod: LogOptions
    public static let requestBody: LogOptions
    public static let requestHeaders: LogOptions
    public static let formatRequestAscURL: LogOptions
    public static let successResponseBody: LogOptions
    public static let errorResponseBody: LogOptions
    public static let `default`: LogOptions
    public static let verbose: LogOptions
    public typealias ArrayLiteralElement = Moya.NetworkLoggerPlugin.Configuration.LogOptions
    public typealias Element = Moya.NetworkLoggerPlugin.Configuration.LogOptions
    public typealias RawValue = Swift.Int
  }
}
extension NetworkLoggerPlugin.Configuration {
  public struct Formatter {
    public typealias DataFormatterType = (Data) -> (String)
    public typealias EntryFormatterType = (_ identifier: String, _ message: String, _ target: TargetType) -> String
    public var entry: EntryFormatterType
    public var requestData: DataFormatterType
    public var responseData: DataFormatterType
    public init(entry: @escaping EntryFormatterType = defaultEntryFormatter, requestData: @escaping DataFormatterType = defaultDataFormatter, responseData: @escaping DataFormatterType = defaultDataFormatter)
    public static func defaultDataFormatter(_ data: Data) -> String
    public static func defaultEntryFormatter(identifier: String, message: String, target: TargetType) -> String
  }
}
extension NetworkLoggerPlugin {
  final public class var `default`: NetworkLoggerPlugin {
    get
  }
  final public class var verbose: NetworkLoggerPlugin {
    get
  }
}
public protocol PluginType {
  func prepare(_ request: URLRequest, target: TargetType) -> URLRequest
  func willSend(_ request: RequestType, target: TargetType)
  func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)
  func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError>
}
extension PluginType {
  public func prepare(_ request: URLRequest, target: TargetType) -> URLRequest
  public func willSend(_ request: RequestType, target: TargetType)
  public func didReceive(_ result: Result<Moya.Response, MoyaError>, target: TargetType)
  public func process(_ result: Result<Moya.Response, MoyaError>, target: TargetType) -> Result<Moya.Response, MoyaError>
}
public protocol RequestType {
  var request: URLRequest? { get }
  var sessionHeaders: [String : String] { get }
  func authenticate(username: String, password: String, persistence: URLCredential.Persistence) -> Self
  func authenticate(with credential: URLCredential) -> Self
  func cURLDescription(calling handler: @escaping (String) -> Void) -> Self
}
final public class Response : CustomDebugStringConvertible, Equatable {
  final public let statusCode: Int
  final public let data: Data
  final public let request: URLRequest?
  final public let response: HTTPURLResponse?
  public init(statusCode: Int, data: Data, request: URLRequest? = nil, response: HTTPURLResponse? = nil)
  final public var description: String {
    get
  }
  final public var debugDescription: String {
    get
  }
  public static func == (lhs: Response, rhs: Response) -> Bool
  @objc deinit
}
extension Response {
  final public func filter<R>(statusCodes: R) throws -> Response where R : Swift.RangeExpression, R.Bound == Swift.Int
  final public func filter(statusCode: Int) throws -> Response
  final public func filterSuccessfulStatusCodes() throws -> Response
  final public func filterSuccessfulStatusAndRedirectCodes() throws -> Response
  final public func mapImage() throws -> Image
  final public func mapJSON(failsOnEmptyData: Bool = true) throws -> Any
  final public func mapString(atKeyPath keyPath: String? = nil) throws -> String
  final public func map<D>(_ type: D.Type, atKeyPath keyPath: String? = nil, using decoder: JSONDecoder = JSONDecoder(), failsOnEmptyData: Bool = true) throws -> D where D : Swift.Decodable
}
public protocol TargetType {
  var baseURL: URL { get }
  var path: String { get }
  var method: Moya.Method { get }
  var sampleData: Data { get }
  var task: Task { get }
  var validationType: ValidationType { get }
  var headers: [String : String]? { get }
}
extension TargetType {
  public var validationType: ValidationType {
    get
  }
  public var sampleData: Data {
    get
  }
}
public enum Task {
  case requestPlain
  case requestData(Data)
  case requestJSONEncodable(Encodable)
  case requestCustomJSONEncodable(Encodable, encoder: JSONEncoder)
  case requestParameters(parameters: [String : Any], encoding: ParameterEncoding)
  case requestCompositeData(bodyData: Data, urlParameters: [String : Any])
  case requestCompositeParameters(bodyParameters: [String : Any], bodyEncoding: ParameterEncoding, urlParameters: [String : Any])
  case uploadFile(URL)
  case uploadMultipart([MultipartFormData])
  case uploadCompositeMultipart([MultipartFormData], urlParameters: [String : Any])
  case downloadDestination(DownloadDestination)
  case downloadParameters(parameters: [String : Any], encoding: ParameterEncoding, destination: DownloadDestination)
}
extension URL {
  public init<T>(target: T) where T : Moya.TargetType
}
public enum ValidationType {
  case none
  case successCodes
  case successAndRedirectCodes
  case customCodes([Int])
}
extension ValidationType : Equatable {
  public static func == (lhs: ValidationType, rhs: ValidationType) -> Bool
}
extension Moya.NetworkActivityChangeType : Swift.Equatable {}
extension Moya.NetworkActivityChangeType : Swift.Hashable {}
